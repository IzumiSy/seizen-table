---
title: Plugin System
description: Learn how to use and create plugins for Seizen DataTable.
---

import { Aside } from '@astrojs/starlight/components';

## Design Philosophy

Seizen DataTable is built on a **plugin-first architecture**. Unlike traditional component libraries that bundle all features into a monolithic package, every feature in Seizen — including official ones — is implemented as a plugin.

This architecture is inspired by modern editor ecosystems like VS Code, where the core remains minimal and all rich functionality comes from extensions. The same principle applies here:

- **The core DataTable does one thing well**: rendering tabular data with essential interactions (sorting, selection, pagination)
- **Everything else is a plugin**: filtering, row details, column controls, data export, and any custom feature you need

### Why Plugin-First?

**Bundle size optimization** — Your users only download the features they actually use. A simple read-only table ships minimal JavaScript, while a feature-rich admin dashboard includes more.

**Consistent mental model** — Whether you're using an official plugin or building a custom one, the API is identical. There's no "magic" built-in behavior that works differently from user-land code.

**Escape hatches by default** — Since official features use the same plugin primitives available to you, you can always fork, extend, or replace any behavior. Nothing is locked away in private APIs.

**Composability** — Plugins can be combined freely. Need filtering in a side panel with row details in an inline row? Just configure both plugins. The slot system ensures they work together seamlessly.

## Layout & Slots

DataTable provides 5 slots where plugins can render UI components:

![DataTable plugin slots layout](/seizen-ui/slots-diagram.svg)

{/* Accessible description for AI/screen readers: DataTable layout has left and right side panels, a header slot above the table body, an inlineRow slot that expands below each row, a cell slot for custom cell rendering, and a footer slot below the table. */}

### Available Slots

| Slot | Description | Rendering Strategy |
|------|-------------|-------------------|
| `sidePanel` | IDE-style vertical tab panel (left or right) | Tab-based toggle |
| `header` | Between table header row and body rows | Sequential (all plugins) |
| `footer` | Below the table | Sequential (all plugins) |
| `cell` | Custom cell renderer for all columns | First match wins |
| `inlineRow` | Expandable sub-row below a specific row | First match wins |

### Slot Rendering Strategies

- **Tab-based toggle**: Only one side panel can be active at a time per position
- **Sequential**: All plugins with this slot render in registration order
- **First match wins**: Only the first plugin with this slot renders

## Using Plugins

```tsx
import { useDataTable, DataTable } from "@izumisy/seizen-datatable-react";
import { RowDetail } from "@izumisy/seizen-datatable-plugin-row-detail";
import { FilterBuilder } from "@izumisy/seizen-datatable-plugin-filter";

function UsersTable() {
  const table = useDataTable({
    data,
    columns,
    plugins: [
      // These will appear as vertical tabs in the side panel
      RowDetail.configure({ render: (row) => <UserDetail user={row} /> }),
      FilterBuilder.configure({ filterableColumns: ["name", "email"] }),
    ],
  });

  return <DataTable table={table} />;
}
```

## Creating Custom Plugins

### Import Path

All plugin development utilities are exported from a dedicated subpath:

```tsx
import {
  definePlugin,
  contextMenuItem,
  usePluginContext,
  type PluginContext,
  type PluginContextValue,
} from "@izumisy/seizen-datatable-react/plugin";
```

### Plugin Types

There are two types of plugins:

1. **Slot Plugin** - Renders UI in one or more slots (sidePanel, header, footer, cell, inlineRow)
2. **Context Menu Only Plugin** - Only adds items to the row context menu (no slot UI)

## Slot Plugin Example

Use `definePlugin` with the `slots` option to create a plugin that uses one or more slots.

```tsx
import { z } from "zod";
import {
  definePlugin,
  usePluginContext,
  type PluginContext,
} from "@izumisy/seizen-datatable-react/plugin";

const MultiSlotSchema = z.object({
  primaryColor: z.string().default("#3b82f6"),
});

type MultiSlotConfig = z.infer<typeof MultiSlotSchema>;

// SidePanel renderer
function createSidePanelRenderer(context: PluginContext<MultiSlotConfig>) {
  return function SidePanelContent() {
    const { data } = usePluginContext();
    return <div>Total: {data.length} rows</div>;
  };
}

// Header renderer
function createHeaderRenderer(context: PluginContext<MultiSlotConfig>) {
  const { args } = context;
  return function HeaderContent() {
    return (
      <div style={{ borderLeft: `3px solid ${args.primaryColor}` }}>
        Header content
      </div>
    );
  };
}

export const MultiSlotPlugin = definePlugin({
  id: "multi-slot",
  name: "Multi Slot",
  args: MultiSlotSchema,
  slots: {
    sidePanel: {
      position: "right-sider",
      header: "Multi Slot Plugin",
      render: createSidePanelRenderer,
    },
    header: {
      render: createHeaderRenderer,
    },
  },
});
```

## Context Menu Only Plugin

Omit `slots` to create a plugin that only adds context menu items.

```tsx
import { z } from "zod";
import { definePlugin, contextMenuItem } from "@izumisy/seizen-datatable-react/plugin";

const RowActionsSchema = z.object({
  enableCopyId: z.boolean().default(true),
  enableDelete: z.boolean().default(false),
});

export const RowActionsPlugin = definePlugin({
  id: "row-actions",
  name: "Row Actions",
  args: RowActionsSchema,
  contextMenu: {
    items: [
      contextMenuItem("copy-id", (ctx) => ({
        label: "Copy ID",
        onClick: () => navigator.clipboard.writeText(String(ctx.row.id)),
        visible: ctx.pluginArgs.enableCopyId,
      })),
      contextMenuItem("delete", (ctx) => ({
        label: `Delete ${ctx.selectedRows.length > 1 ? `${ctx.selectedRows.length} items` : "item"}`,
        onClick: () => handleDelete(ctx.selectedRows.length > 0 ? ctx.selectedRows : [ctx.row]),
        visible: ctx.pluginArgs.enableDelete,
        disabled: ctx.selectedRows.length === 0,
      })),
    ],
  },
});
```

## Plugin Context (`usePluginContext`)

Inside your plugin component, use `usePluginContext` to access table data and APIs.

```tsx
const {
  table,         // DataTable instance
  data,          // Current table data (unknown[])
  columns,       // Column info ({ key, header }[])
  selectedRows,  // Currently selected rows (unknown[])
  openArgs,      // Arguments passed via table.plugin.open()
  useEvent,      // Hook to subscribe to events
} = usePluginContext();
```

### `openArgs` - Receiving Initial Data

When a plugin is opened with `table.plugin.open(pluginId, args)`, the `args` are available via `openArgs`:

```tsx
// Application side
table.plugin.open("row-detail", { row: clickedRow });

// Inside plugin
const { openArgs } = usePluginContext<"row-detail">();
const initialRow = openArgs?.row;
```

<Aside type="tip">
  See the [live example](/seizen-ui/examples/) to explore plugins in action.
</Aside>
