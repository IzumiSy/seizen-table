---
title: Advanced
description: Advanced usage patterns for Seizen DataTable.
---

## Three Levels of Abstraction

Seizen DataTable provides three levels of API abstraction. Choose the level that best fits your needs:

### Level 1: High-Level API (All-in-One)

The simplest approach - just pass a table instance and configuration:

```tsx
import { DataTable, useDataTable } from "@izumisy/seizen-datatable-react";

function MyComponent() {
  const table = useDataTable({ data, columns });
  
  return <DataTable table={table} paginate={{ enable: true }} />;
}
```

**When to use**: Quick setup, standard layouts, minimal customization needed.

### Level 2: Compound Components (Mid-Level)

Build custom layouts using compound components while keeping plugin support:

```tsx
import { DataTable, DataTablePlugins, useDataTable } from "@izumisy/seizen-datatable-react";

function MyComponent() {
  const table = useDataTable({ data, columns, plugins: [MyPlugin] });
  
  return (
    <DataTable.Root table={table}>
      <DataTablePlugins.SidePanel position="left" />
      <DataTablePlugins.Header />
      <DataTable.Table>
        <thead>
          <DataTable.Header />
        </thead>
        <tbody>
          <DataTable.Body />
        </tbody>
      </DataTable.Table>
      <DataTablePlugins.Footer />
      <DataTable.Paginator sizeOptions={[10, 25, 50]} />
      <DataTablePlugins.SidePanel position="right" />
    </DataTable.Root>
  );
}
```

**When to use**: Custom layouts, reordering components, conditional rendering, but still want plugins and context menus.

**Note**: Most compound components automatically get the table instance from `DataTable.Root` via context, so you don't need to pass `table` prop to each component.

#### Component Overview

**DataTable Compound Components** (table structure):

| Component | Description |
|-----------|-------------|
| `DataTable.Root` | Provider wrapper (required, provides context) |
| `DataTable.Table` | Pure `<table>` element wrapper |
| `DataTable.Header` | Column headers with sorting and context menu |
| `DataTable.Body` | Row rendering with render props support |
| `DataTable.Row` | Individual row with click handlers |
| `DataTable.Cell` | Individual cell with context menu support |
| `DataTable.Paginator` | Pagination controls |

**DataTablePlugins** (plugin UI slots):

| Component | Description |
|-----------|-------------|
| `DataTablePlugins.SidePanel` | Left/right sidepanels for plugin content |
| `DataTablePlugins.Header` | Plugin header slots (e.g., filter bars) |
| `DataTablePlugins.Footer` | Plugin footer slots |
| `DataTablePlugins.InlineRow` | Expandable row content (e.g., row details) |
| `DataTablePlugins.CellSlot` | Custom cell rendering from plugins |

#### Component Hierarchy

```
DataTable.Root (providers + context)
├─ DataTablePlugins.SidePanel position="left"
├─ DataTablePlugins.Header (plugin-provided toolbars)
├─ DataTable.Table
│  ├─ <thead>
│  │  └─ DataTable.Header
│  └─ <tbody>
│     └─ DataTable.Body
│        ├─ DataTable.Row
│        │  └─ DataTable.Cell
│        └─ DataTablePlugins.InlineRow
├─ DataTablePlugins.Footer (plugin-provided footers)
├─ DataTable.Paginator
└─ DataTablePlugins.SidePanel position="right"
```

#### Custom Row Rendering with Render Props

`DataTable.Body` supports render props for custom row rendering:

```tsx
import { DataTable, DataTablePlugins, useDataTable } from "@izumisy/seizen-datatable-react";

function CustomRowsTable() {
  const table = useDataTable({ data, columns });
  
  return (
    <DataTable.Root table={table}>
      <DataTable.Table>
        <thead>
          <DataTable.Header />
        </thead>
        <tbody>
          <DataTable.Body>
            {(row) => (
              <>
                <DataTable.Row
                  row={row}
                  className={row.original.isVIP ? "vip-row" : ""}
                  onClick={(row) => console.log("Clicked:", row.original)}
                />
                {/* InlineRow for expandable content */}
                <DataTablePlugins.InlineRow 
                  row={row} 
                  colSpan={row.getVisibleCells().length} 
                />
              </>
            )}
          </DataTable.Body>
        </tbody>
      </DataTable.Table>
    </DataTable.Root>
  );
}
```

**Default behavior**: When no children are provided, `DataTable.Body` automatically renders `DataTable.Row` and `DataTablePlugins.InlineRow` for each row.

**Opting out of InlineRow**: If you don't need expandable rows, simply omit `DataTablePlugins.InlineRow`:

```tsx
<DataTable.Body>
  {(row) => <DataTable.Row row={row} />}
</DataTable.Body>
```

#### Custom Cell Content

`DataTable.Cell` supports custom children with optional plugin slot integration:

```tsx
// Default: uses plugin CellSlot automatically
<DataTable.Cell cell={cell} row={row} />

// Custom content without plugin support
<DataTable.Cell cell={cell} row={row}>
  <span className="custom">{cell.getValue()}</span>
</DataTable.Cell>

// Custom content with plugin support
<DataTable.Cell cell={cell} row={row}>
  <DataTablePlugins.CellSlot cell={cell} column={cell.column} row={row}>
    <span className="custom">{cell.getValue()}</span>
  </DataTablePlugins.CellSlot>
</DataTable.Cell>
```

#### Adding Custom Elements

You can add custom elements between or around table components:

```tsx
<DataTable.Root table={table}>
  <DataTablePlugins.SidePanel position="left" />
  
  {/* Custom toolbar */}
  <div className="custom-toolbar">
    <button>Export</button>
    <button>Refresh</button>
  </div>
  
  <DataTablePlugins.Header />
  
  <DataTable.Table>
    <thead><DataTable.Header /></thead>
    <tbody><DataTable.Body /></tbody>
  </DataTable.Table>
  
  <DataTablePlugins.Footer />
  
  {/* Custom footer content */}
  <div className="table-info">
    Showing {table.getData().length} records
  </div>
  
  <DataTable.Paginator />
  <DataTablePlugins.SidePanel position="right" />
</DataTable.Root>
```

#### Using Context Menu Hook

For completely custom cell rendering with context menu support:

```tsx
import { 
  DataTable, 
  useDataTable, 
  useDataTableContext,
  useContextMenu,
  flexRender 
} from "@izumisy/seizen-datatable-react";

function CustomCellsTable() {
  const table = useDataTable({ data, columns });
  
  return (
    <DataTable.Root table={table}>
      <DataTable.Table>
        <thead>
          <DataTable.Header />
        </thead>
        <tbody>
          <CustomTableBody />
        </tbody>
      </DataTable.Table>
    </DataTable.Root>
  );
}

function CustomTableBody() {
  const table = useDataTableContext();
  const { handleCellContextMenu } = useContextMenu();
  
  return (
    <>
      {table._tanstackTable.getRowModel().rows.map((row) => (
        <tr
          key={row.id}
          onClick={() => table.eventBus.emit("row-click", row.original)}
        >
          {row.getVisibleCells().map((cell) => (
            <td
              key={cell.id}
              className="custom-cell"
              onContextMenu={(e) => 
                handleCellContextMenu(e, cell, cell.column, row)
              }
            >
              {flexRender(cell.column.columnDef.cell, cell.getContext())}
            </td>
          ))}
        </tr>
      ))}
    </>
  );
}
```

**Available Hooks**:
- **`useDataTableContext()`**: Get the table instance from context
- **`useContextMenu()`**: Get `handleCellContextMenu` and `handleColumnContextMenu` functions

### Level 3: Low-Level API (TanStack Table Direct)

For maximum control, use TanStack Table API directly without DataTable components:

```tsx
import { useDataTable, flexRender, type ColumnDef } from "@izumisy/seizen-datatable-react";

function CustomTable<TData>({ 
  data, 
  columns 
}: { 
  data: TData[]; 
  columns: ColumnDef<TData>[] 
}) {
  const table = useDataTable({ data, columns });
  const tanstack = table._tanstackTable;

  return (
    <table>
      <thead>
        {tanstack.getHeaderGroups().map((headerGroup) => (
          <tr key={headerGroup.id}>
            {headerGroup.headers.map((header) => (
              <th key={header.id}>
                {header.isPlaceholder
                  ? null
                  : flexRender(header.column.columnDef.header, header.getContext())}
              </th>
            ))}
          </tr>
        ))}
      </thead>
      <tbody>
        {tanstack.getRowModel().rows.map((row) => (
          <tr key={row.id}>
            {row.getVisibleCells().map((cell) => (
              <td key={cell.id}>
                {flexRender(cell.column.columnDef.cell, cell.getContext())}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

**When to use**: Complete custom UI, no plugins needed, performance-critical scenarios.

**Note**: This approach loses plugin support and context menus. Use Level 2 (Compound Components) if you need those features.

## Summary: Choosing the Right Level

| Feature | Level 1 (High) | Level 2 (Mid) | Level 3 (Low) |
|---------|----------------|---------------|---------------|
| **Setup Complexity** | Minimal | Moderate | High |
| **Customization** | Limited | High | Complete |
| **Plugin Support** | ✅ Yes | ✅ Yes | ❌ No |
| **Context Menus** | ✅ Yes | ✅ Yes | ❌ No |
| **Layout Control** | ❌ No | ✅ Yes | ✅ Yes |
| **Best For** | Quick setup | Custom layouts with plugins | Completely custom UI |

**Recommendation**: Start with Level 1, move to Level 2 when you need custom layouts but want to keep plugin features, and only use Level 3 when building a completely custom table from scratch.
