---
title: Data Adapter
description: Connect your SeizenTable to any backend with Data Adapters.
---

import { Aside } from '@astrojs/starlight/components';

## Why Data Adapters?

Enterprise applications rarely work with static, in-memory data. Real-world scenarios involve:

- **Remote data sources**: REST APIs, GraphQL endpoints, gRPC services
- **Server-side operations**: Pagination, sorting, and filtering handled by the backend
- **Complex state management**: Loading states, error handling, caching, optimistic updates
- **Protocol diversity**: Different backends require different query formats and response handling

Without abstraction, you end up with:

```tsx
// ❌ Tight coupling to specific API format
function UsersTable() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(0);
  
  useEffect(() => {
    setLoading(true);
    fetch(`/api/users?page=${page}&limit=10`)
      .then(res => res.json())
      .then(data => {
        setData(data.items);
        setLoading(false);
      });
  }, [page]);
  
  // ... repeat for sorting, filtering, etc.
}
```

This approach has problems:
- API format is hardcoded throughout the component
- Switching backends requires rewriting data fetching logic
- Difficult to test and maintain
- No reusability across different tables

## The Data Adapter Solution

Data Adapters provide a **protocol-agnostic abstraction** for fetching and managing table data:

```tsx
// ✅ Clean separation of concerns
const usersAdapter = GraphQLAdapter.configure({
  client: apolloClient,
  query: GET_USERS_QUERY,
  transform: (data) => ({
    data: data.users.nodes,
    totalCount: data.users.totalCount,
  }),
});

function UsersTable() {
  const { state } = useAdapter(usersAdapter);
  
  return (
    <SeizenTable
      data={state.data}
      columns={columns}
      isLoading={state.isLoading}
    />
  );
}
```

Benefits:
- **Swap backends easily**: Change from REST to GraphQL without touching table code
- **Consistent API**: Same interface regardless of underlying protocol
- **Built-in state management**: Loading, error, pagination states handled automatically
- **Testable**: Mock adapters for testing without network calls

## Pagination Modes

Data Adapters support two pagination strategies:

### Offset Pagination

Traditional page-based pagination. Best for:
- Datasets where users need to jump to specific pages
- Backends that support `OFFSET` / `LIMIT` queries
- When total count is always available

```typescript
interface OffsetPaginationState {
  mode: "offset";
  pageIndex: number;  // Current page (0-based)
  pageSize: number;   // Items per page
}
```

### Cursor Pagination

Cursor-based pagination (common in GraphQL). Best for:
- Large or frequently-changing datasets
- Real-time data where offset would cause duplicates/gaps
- Backends that use cursor-based queries (Relay-style)

```typescript
interface CursorPaginationState {
  mode: "cursor";
  pageSize: number;
  startCursor: string | null;
  endCursor: string | null;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}
```

### Comparison

| Feature | Offset Mode | Cursor Mode |
|---------|-------------|-------------|
| Jump to page | ✅ `goToPage(n)` | ❌ Not supported |
| Next/Previous | ✅ `nextPage()` / `previousPage()` | ✅ `nextPage()` / `previousPage()` |
| Total count | ✅ Always available | ⚠️ May be null |
| Performance | ⚠️ Slower on large datasets | ✅ Consistent performance |
| Real-time data | ⚠️ May skip/duplicate on changes | ✅ Stable cursor position |

## Defining Custom Adapters

Use `defineDataAdapter` to create custom adapters:

```typescript
import { defineDataAdapter } from "@izumisy/seizen-table";

const MyCustomAdapter = defineDataAdapter({
  id: "my-custom-adapter",

  // Initialize adapter state
  initialState: {
    data: [],
    totalCount: 0,
    isLoading: false,
    error: null,
    pageIndex: 0,
    pageSize: 10,
  },

  // Fetch implementation
  fetch: async (state, options) => {
    const response = await myApi.getItems({
      page: state.pageIndex,
      limit: state.pageSize,
      sort: state.sorting,
      filter: state.filter,
    });
    return {
      data: response.items,
      totalCount: response.total,
    };
  },
});
```

## Built-in Adapters

### GraphQL Adapter

For Apollo Client or similar GraphQL clients:

```typescript
import { GraphQLAdapter } from "@izumisy/seizen-datatable-adapter-graphql";

const usersAdapter = GraphQLAdapter.configure({
  client: apolloClient,
  query: GET_USERS_QUERY,
  variables: (state) => ({
    first: state.pageSize,
    offset: state.pageIndex * state.pageSize,
    filter: state.filter,
    orderBy: state.sorting,
  }),
  transform: (data) => ({
    data: data.users.nodes,
    totalCount: data.users.totalCount,
  }),
});
```

### REST/OpenAPI Adapter

For REST APIs:

```typescript
import { RESTAdapter } from "@izumisy/seizen-datatable-adapter-rest";

const usersAdapter = RESTAdapter.configure({
  baseUrl: "/api/users",
  buildUrl: (state) => ({
    params: {
      page: state.pageIndex,
      limit: state.pageSize,
      sort: state.sorting?.[0]?.id,
      order: state.sorting?.[0]?.desc ? "desc" : "asc",
    },
  }),
  transform: (response) => ({
    data: response.items,
    totalCount: response.total,
  }),
});
```

## Adapter API

The adapter instance provides a framework-agnostic API:

```typescript
// State (readonly)
adapter.state.data;        // TData[]
adapter.state.totalCount;  // number
adapter.state.isLoading;   // boolean
adapter.state.error;       // Error | null
adapter.state.pageIndex;   // number
adapter.state.pageSize;    // number

// Actions
adapter.fetch();                    // Fetch data
adapter.refetch();                  // Refetch current page
adapter.setPageIndex(2);            // Go to page
adapter.setPageSize(20);            // Change page size
adapter.setFilter({ status: "active" });  // Set filter
adapter.setSorting([{ id: "name", desc: false }]);  // Set sorting
```

## Usage with SeizenTable

```tsx
import { useAdapter } from "@izumisy/seizen-table";

const usersAdapter = GraphQLAdapter.configure({
  client: apolloClient,
  query: GET_USERS_QUERY,
  // ...
});

function UsersTable() {
  // useAdapter subscribes to state changes and triggers re-render
  const { state, actions } = useAdapter(usersAdapter);

  return (
    <SeizenTable
      data={state.data}
      columns={columns}
      isLoading={state.isLoading}
    />
  );
}
```

<Aside type="note">
  Data adapters are optional. For static data or client-side filtering, you can pass data directly to `useSeizenTable`.
</Aside>
